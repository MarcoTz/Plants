use super::{PlantLocation, PlantSpecies};
use crate::{
    errors::Error,
    serialize::{date_serializer, location_serializer, species_serializer},
};
use chrono::NaiveDate;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Serialize, Clone, Deserialize, Debug, PartialEq)]
pub struct PlantInfo {
    pub name: String,
    #[serde(with = "species_serializer")]
    pub species: PlantSpecies,
    #[serde(with = "location_serializer")]
    pub location: PlantLocation,
    pub origin: String,
    #[serde(with = "date_serializer")]
    pub obtained: NaiveDate,
    pub auto_water: bool,
    pub notes: Vec<String>,
}

impl TryFrom<HashMap<String, String>> for PlantInfo {
    type Error = Error;
    ///Converts from a HashMap generated by the sqlite backend
    ///requires all keys to be present
    ///including a key "date_format" to parse dates
    fn try_from(map: HashMap<String, String>) -> Result<PlantInfo, Error> {
        let date_format = map.get("date_format").ok_or(Error::KeyNotFound {
            key: "date_format".to_owned(),
            task: "PlantInfo".to_owned(),
        })?;
        let read_fun = |key: &str| {
            map.get(key).cloned().ok_or(Error::KeyNotFound {
                key: key.to_owned(),
                task: "PlantInfo".to_owned(),
            })
        };

        let species_name = read_fun("species")?;
        let location_name = read_fun("location")?;
        let auto_water = read_fun("auto_water")? == "1";
        let notes = read_fun("notes")?;
        Ok(PlantInfo {
            name: read_fun("name")?,
            species: PlantSpecies::Other(species_name),
            location: PlantLocation::Other(location_name),
            origin: read_fun("origin")?,
            obtained: NaiveDate::parse_from_str(&read_fun("obtained")?, &date_format)?,
            auto_water,
            notes: notes.split(", ").map(|s| s.to_owned()).collect(),
        })
    }
}
